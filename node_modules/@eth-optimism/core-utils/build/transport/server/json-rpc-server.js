"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRpcServer = void 0;
const types_1 = require("../../types");
const json_rpc_errors_1 = require("./json-rpc-errors");
const express_http_server_1 = require("./express-http-server");
class JsonRpcServer extends express_http_server_1.ExpressHttpServer {
    constructor(methods = {}, hostname, port, middleware) {
        super(port, hostname, middleware);
        this.methods = methods;
    }
    initRoutes() {
        this.app.post('/', async (req, res) => {
            const request = req.body;
            if (!types_1.isJsonRpcRequest(request)) {
                return res.json(json_rpc_errors_1.buildJsonRpcError('INVALID_REQUEST', null));
            }
            if (!(request.method in this.methods)) {
                return res.json(json_rpc_errors_1.buildJsonRpcError('METHOD_NOT_FOUND', request.id));
            }
            let result;
            try {
                result = await this.methods[request.method](request.params);
            }
            catch (err) {
                return res.json(json_rpc_errors_1.buildJsonRpcError('INTERNAL_ERROR', request.id));
            }
            const response = {
                jsonrpc: request.jsonrpc,
                id: request.id,
                result,
            };
            return res.json(response);
        });
    }
    register(name, method) {
        if (name in this.methods) {
            throw new Error(`method already registered: ${name}`);
        }
        this.methods[name] = method;
    }
}
exports.JsonRpcServer = JsonRpcServer;
//# sourceMappingURL=json-rpc-server.js.map