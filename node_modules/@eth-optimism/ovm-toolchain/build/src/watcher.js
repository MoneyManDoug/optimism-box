"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Watcher = void 0;
const ethers_v4_1 = require("ethers-v4");
class Watcher {
    constructor(opts) {
        this.l1 = opts.l1;
        this.l2 = opts.l2;
    }
    async getMessageHashesFromL1Tx(l1TxHash) {
        return this._getMessageHashesFromTx(true, l1TxHash);
    }
    async getMessageHashesFromL2Tx(l2TxHash) {
        return this._getMessageHashesFromTx(false, l2TxHash);
    }
    onceL2Relay(msgHash, callback) {
        return this._onceRelay(false, msgHash, callback);
    }
    onceL1Relay(msgHash, callback) {
        return this._onceRelay(true, msgHash, callback);
    }
    async _getMessageHashesFromTx(isL1, txHash) {
        const layer = isL1 ? this.l1 : this.l2;
        const l1Receipt = await layer.provider.getTransactionReceipt(txHash);
        const filtered = l1Receipt.logs.filter((log) => {
            return (log.address === layer.messengerAddress &&
                log.topics[0] === ethers_v4_1.ethers.utils.id('SentMessage(bytes32)'));
        });
        return filtered.map((log) => log.data);
    }
    _onceRelay(isL1, msgHash, callback) {
        const layer = isL1 ? this.l1 : this.l2;
        const filter = {
            address: layer.messengerAddress,
            topics: [
                ethers_v4_1.ethers.utils.id(`Relayed${isL1 ? 'L2ToL1' : 'L1ToL2'}Message(bytes32)`),
            ],
        };
        layer.provider.on(filter, (log) => {
            if (log.data === msgHash) {
                callback(log.transactionHash);
            }
        });
    }
}
exports.Watcher = Watcher;
//# sourceMappingURL=watcher.js.map