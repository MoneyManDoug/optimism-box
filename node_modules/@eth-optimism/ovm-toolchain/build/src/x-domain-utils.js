"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.relayL1ToL2Messages = exports.relayL2ToL1Messages = exports.initCrossDomainMessengers = void 0;
const contracts_1 = require("@eth-optimism/contracts");
const getContractFromDefinition = (ethers, signer, name, args = []) => {
    const contractDefinition = contracts_1.getContractDefinition(name);
    const contractFactory = new ethers.ContractFactory(contractDefinition.abi, contractDefinition.bytecode, signer);
    return contractFactory.deploy(...args);
};
exports.initCrossDomainMessengers = async (l1ToL2MessageDelay, l2ToL1MessageDelay, ethers, signer) => {
    const l2CrossDomainMessenger = await getContractFromDefinition(ethers, signer, 'mockOVM_CrossDomainMessenger', [l1ToL2MessageDelay]);
    const l1CrossDomainMessenger = await getContractFromDefinition(ethers, signer, 'mockOVM_CrossDomainMessenger', [l2ToL1MessageDelay]);
    await l1CrossDomainMessenger.setTargetMessengerAddress(l2CrossDomainMessenger.address);
    await l2CrossDomainMessenger.setTargetMessengerAddress(l1CrossDomainMessenger.address);
    signer.provider.__l1CrossDomainMessenger = l1CrossDomainMessenger;
    signer.provider.__l2CrossDomainMessenger = l2CrossDomainMessenger;
    return {
        l1CrossDomainMessenger,
        l2CrossDomainMessenger,
    };
};
exports.relayL2ToL1Messages = async (signer) => {
    return relayXDomainMessages(true, signer);
};
exports.relayL1ToL2Messages = async (signer) => {
    return relayXDomainMessages(false, signer);
};
const relayXDomainMessages = async (isL1, signer) => {
    const messenger = isL1
        ? signer.provider.__l1CrossDomainMessenger
        : signer.provider.__l2CrossDomainMessenger;
    if (!messenger) {
        throw new Error('Messengers are not initialized. Please make sure to call initCrossDomainMessengers!');
    }
    do {
        await messenger.relayNextMessage();
    } while (await messenger.hasNextMessage());
};
//# sourceMappingURL=x-domain-utils.js.map